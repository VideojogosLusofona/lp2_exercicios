19 - Considera a seguinte classe:

```cs
using UnityEngine;

public static class VectorOperations
{
    // Normalized direction between two game objects
    public static Vector2 Direction(Vector2 from, Vector2 to)
    {
        return (to - from) / (to - from).magnitude;
    }

    // Distance between two game objects
    public static float Distance(Vector2 obj1, Vector2 obj2)
    {
        return (obj1 - obj2).magnitude;
    }

    // Convert angle in degrees into normalized vector
    public static Vector2 Deg2Vec(float angle)
    {
        float angleRad = angle * Mathf.Deg2Rad;
        return new Vector2(Mathf.Cos(angleRad), Mathf.Sin(angleRad));
    }

    // Determine angle of vector in degrees
    public static float Vec2Deg(Vector2 vector)
    {
        return Mathf.Atan2(vector.y, vector.x) * Mathf.Rad2Deg;
    }
}
```

Responde às seguintes questões:

1. Simplifica os métodos usando notação lambda (`=>`).
2. Declara, para cada método, um _delegate_ personalizado compatível.
3. Indica, para cada método, um _delegate_ pré-definido do C# que seja
   compatível.
4. Assumindo que estás num método noutra classe, escreve quatro linhas de
   código nas quais declaras quatro variáveis do tipo _delegate_ pré-definido
   que indicaste na alínea anterior, atribuindo-lhes o respetivo método
   compatível.
5. Repete a alínea anterior mas considerando os _delegates_ personalizados que
   declaraste na alínea 2 (e não os _delegates_ pré-definidos do C#).

> [Soluções](../solucoes/02/019.md)

SOLUÇÃO #1

1.

    Normalized direction between two game objects
    (to, from) => (to - from) / (to - from).magnitude;

    ou, caso o 'lambda' n consiga percerber de que se trada de um vector

    (Vector2 to, Vector2 from) => (to - from) / (to - from).magnitude;


    Distance between two game objects
    (obj1, obj2) => (obj1 - obj2).magnitude;

    ou

    (Vector2 obj1, Vector2 obj2) => (obj1 - obj2).magnitude;


    Convert angle in degrees into normalized vector
    (float angle) => { float angleRad = angle * Mathf.Deg2Rad;
            return new Vector2(Mathf.Cos(angleRad), Mathf.Sin(angleRad); }


    Determine angle of vector in degrees
    (float a, vector v) => Mathf.Atan2(vector.y, vector.x) * Mathf.Rad2Deg;

    ou

    (float a, Vector2 v) => Mathf.Atan2(vector.y, vector.x) * Mathf.Rad2Deg;


2.

    (Vector2 to, Vector2 from) => (to - from) / (to - from).magnitude;
    |
    v  
    public delegate Vector2 VectorOperation = (Vector2 a, Vector2 b);


    (Vector2 obj1, Vector2 obj2) => (obj1 - obj2).magnitude;
    |
    v  
    public delegate Vector2 VectorOperation = (Vector2 a, Vector2 b);
    (o 'delegate' anterior resultaria também nesta situação)


    (float angle) => { float angleRad = angle * Mathf.Deg2Rad;
            return new Vector2(Mathf.Cos(angleRad), Mathf.Sin(angleRad); }
    |
    v
    public delegate float GetAngleNormalized(float a, Vector2 v)


    (float a, Vector2 v) => Mathf.Atan2(vector.y, vector.x) * Mathf.Rad2Deg;
    |
    v  
    public delegate float GetAngle = (float a, Vector2 v);


3.

    (Vector2 to, Vector2 from) => (to - from) / (to - from).magnitude;
    |
    v  
    public delegate Vector2 Func <Vector2, Vector2, Vector2>(Vector2 a, Vector2 b);


    (Vector2 obj1, Vector2 obj2) => (obj1 - obj2).magnitude;
    |
    v  
    public delegate Vector2 Func <Vector2, Vector2, Vector2>(Vector2 a, Vector2 b);
    (o 'delegate' anterior resultaria também nesta situação)


    (float angle) => { float angleRad = angle * Mathf.Deg2Rad;
            return new Vector2(Mathf.Cos(angleRad), Mathf.Sin(angleRad); }
    |
    v
    public delegate Vector2 Func <float, Vector2, Vector2>(float a, Vector2 v);


    (float a, Vector2 v) => Mathf.Atan2(vector.y, vector.x) * Mathf.Rad2Deg;
    |
    v  
    public delegate float Func <float, Vector2, float>(float a, Vector2 v);


4.

