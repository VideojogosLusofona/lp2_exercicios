## Pergunta

22 - Considera a seguinte classe:

```cs
public abstract class GameItem
{
    public readonly string name;
    public readonly string description;

    public GameItem(string name, string description)
    {
        this.name = name;
        this.description = description;
    }
}
```

Responde às seguintes questões:

1. Implementa a classe `Sword` que estende `GameItem`, tendo adicionalmente
   como estado os campos `length`, `typeOfMetal` e `condition`. O primeiro
   pode ser representado com um número real, e os outros têm um tipo próprio,
   `TypeOfMetal` e `WeaponCondition`, respetivamente. O construtor de `Sword`
   aceita 5 parâmetros, que são usados para inicializar todos os campos da
   classe. No entanto, os campos herdados de `GameItem` devem ser
   inicializados pelo respetivo construtor.
2. Cria as enumerações `TypeOfMetal` e `WeaponCondition` com valores à tua
   escolha mas de modo a que façam sentido no contexto do problema.
3. Dá um exemplo em código de como podemos criar uma instância de `Sword`.
4. Normalmente as variáveis de instância têm visibilidade privada de modo a
   não comprometer a encapsulação. No entanto não é esse o caso no código
   apresentado. Porque razão a quebra de encapsulação não é tão grave neste
   caso?
5. Podemos instanciar diretamente `GameItem`? Porquê?

## Soluções

### Solução 1

1.
```cs
    class Sword : GameItem
    {
        public readonly int length;
        public readonly TypeOfMetal typeOfMetal;
        public readonly WeaponCondition condition;

        public Sword(
        string name, 
        string description, 
        int length, 
        TypeOfMetal typeOfMetal, 
        WeaponCondition condition)
            : base(name, description)
        {
            this.length = length;
            this.typeOfMetal = typeOfMetal;
            this.condition = condition;
        }
    }
```

2.
```cs
    enum TypeOfMetal
    {
        Bronze,
        Iron,
        Steel,
        ValyrianSteel
    }
```

```cs
    enum WeaponCondition
    {
        Ruined,
        BadlyDamaged,
        Damaged,
        Worn,
        Pristine
    }
```

3.
```cs
    class Program
    {
        static void Main(string[] args)
        {
            Sword s1 = new Sword(
            "Oathkeeper", 
            "Made from 'Ice' - The greatsword of House Stark", 
            2, 
            TypeOfMetal.ValyrianSteel, 
            WeaponCondition.Pristine);

            Console.WriteLine($"Sword name: {s1.name}");
            Console.WriteLine($"Sword description: {s1.description}");
            Console.WriteLine($"Sword length: {s1.length}");
            Console.WriteLine($"Sword metal type: {s1.typeOfMetal}");
            Console.WriteLine($"Sword condition: {s1.condition}");
        }
    }
```

4.
A quebra de encapsulação que verificamos neste caso não é grave, pois estas variáveis são variáveis com o modificador "readonly", ou seja, variáveis que são só de leitura.

5.
Não. Em C# não se podem instanciar classes abstratas.

Solução por [Tiago Alves](https://github.com/synpse)
