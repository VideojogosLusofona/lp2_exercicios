## Problema

41 - Cria uma classe chamada `HighScoreManager`, que contém internamente uma
coleção com um máximo de 10 `Tuple<string, float>`, cada um representando o
nome de um jogador e o respetivo _score_. Além da coleção referida, a classe
deve ainda conter:

* Um construtor, que aceita opcionalmente um nome de ficheiro (deve existir
  um nome por omissão), e:
  * Caso o ficheiro não exista, inicializa a coleção sem elementos.
  * Caso o ficheiro exista, abre-o e inicializa a coleção de modo a que
    contenha os nomes e _scores_ especificados no ficheiro.
  * Caso o ficheiro exista, mas tenha um formato inválido, lançar uma excepção
    do tipo `InvalidOperationException`.
* Um método `AddScore(string name, float score)`, que adiciona um novo
  `Tuple<string, float>` à coleção. Se o número de _scores_ ultrapassar 10, o
  tuplo contendo o menor _score_ deve ser removido.
* Um método `Save()`, que guarda os _scores_ no ficheiro especificado no
  construtor.
* Um método `ToString()`, que devolve uma _string_ contendo uma tabela
  devidamente formatada com todos os nomes e _scores_, do mais alto ao mais
  baixo.
* Um método iterável `GetScores()` que retorna de forma ordenada (do _score_
  mais alto até ao _score_ mais baixo) todos tuplos guardados na coleção.

O formato do ficheiro de _high scores_ fica ao critério dos alunos.

Cria também uma classe `Program` com um método `Main` para testar os vários
métodos da classe `HighScoreManager`.

## Soluções

### Solução 1

Classe `HighScoreManager`
```csharp
using System;
using System.IO;
using System.Text;

namespace Ex_41
{
    public class HighscoreManager
    {
        // Coleção onde escrever os valores lidos
        private Tuple<string, float>[] _scores;
        private string _file;

        public HighscoreManager(string file = "Scores.txt")
        {
            _file = file;
            // Verificar se o ficheiro existe
            if (!File.Exists(_file))
            {
                Console.WriteLine("file doesn't exist, " +
                    "initializing Scores without elements");
                _scores = new Tuple<string, float>[10];
            }
            else if (Path.GetExtension(_file) != ".txt")
            {
                throw new InvalidOperationException();
            }
            else
            {
                _scores = new Tuple<string, float>[10];
                ReadFile();
            }
        }

        public void Save()
        {
            try
            {
                using (StreamWriter sw = new StreamWriter(_file))
                {
                    sw.Flush();
                    for (int i = 0; i < _scores.Length; i++)
                    {
                        sw.WriteLine(ScoreLine(_scores[i]));
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Couldn't save file");
                Console.WriteLine(e.Message);
            }
        }

        // Função intermédia para a string de um score
        private string ScoreLine(Tuple<string, float> score)
        {
            if (score == null) return "";
            return score.Item1 + ' ' + score.Item2.ToString();
        }

        // Adiciona um Score através do nome e do valor
        public void AddScore(string name, float score)
        {
            Tuple<string, float> newScore;
            newScore = new Tuple<string, float>(name, score);

            if (_scores[0] == null)
            {
                _scores[0] = newScore;
                return;
            }


            // Variável de suporte para o menor score
            float lowestScore;
            int lsIndex;

            lowestScore = _scores[0].Item2;
            lsIndex = 0;

            // Iterar sobre os scores
            for (int i = 0; i < _scores.Length; i++)
            {
                // Se houver um nulo, igualar ao recebido e acabar
                if (_scores[i] == null)
                {
                    _scores[i] = newScore;
                    return;
                }
                // Verificar o score
                else if (_scores[i].Item2 < lowestScore)
                {
                    lowestScore = _scores[i].Item2;
                    lsIndex = i;
                }
            }

            _scores[lsIndex] = newScore;
        }

        public void AddScore(Tuple<string, float> newScore)
        {
            float lowestScore;
            int lsIndex;

            lowestScore = _scores[0].Item2;
            lsIndex = 0;

            for (int i = 0; i < _scores.Length; i++)
            {
                if (_scores[i] == null)
                {
                    _scores[i] = newScore;
                    return;
                }
                else if (_scores[i].Item2 < lowestScore)
                {
                    lowestScore = _scores[i].Item2;
                    lsIndex = i;
                }
            }
            _scores[lsIndex] = newScore;
        }

        private void ReadFile()
        {
            try
            {
                using (StreamReader sr = new StreamReader(_file))
                {
                    string line;

                    for (int i = 0; i < _scores.Length; i++)
                    {
                        if ((line = sr.ReadLine()) != null)
                            _scores[i] = GetPlayerScore(line);
                        else
                            break;
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Couldn't read from file, something went wrong");
                Console.WriteLine(e.Message);
            }
        }

        // Função de ajuda para tirar um score (par nome, valor) de cada linha.
        // Consideremos assim que cada score tem o Nome e o valor separado por ' '.
        private Tuple<string, float> GetPlayerScore(string line)
        {
            Tuple<string, float> playerScore;
            string[] score;

            // Retirar o nome e o valor em string da linha lida
            score = line.Split(' ');

            // Criar um Tuplo com o nome e o valor do jogador
            playerScore = new Tuple<string, float>
                (score[0], Convert.ToSingle(score[1]));

            return playerScore;
        }

        public override string ToString()
        {
            StringBuilder sb;
            sb = new StringBuilder("\t SCORES \n");

            for (int i = 0; i < _scores.Length; i++)
            {
                sb.AppendLine(ScoreLine(_scores[i]));
            }

            return sb.ToString();
        }
    }
}
```

Método `Main` para o teste da classe.

```csharp
using System;

namespace Ex_41
{
    class Program
    {
        static void Main(string[] args)
        {
            HighscoreManager hsMng;

            hsMng = new HighscoreManager();

            hsMng.AddScore("Joao", 2);
            hsMng.AddScore("Raquel", 10220);
            hsMng.AddScore("Catarina", 2);
            hsMng.AddScore("Rodrigo", 102330);
            hsMng.AddScore("Henrique", 2);
            hsMng.AddScore("Batman", 222222);
            hsMng.AddScore("Anakin", 2);
            hsMng.AddScore("Darth", 222222);
            hsMng.AddScore("Vader", 2);
            hsMng.AddScore("Harry", 100);
            hsMng.AddScore("Potter", 100);
            hsMng.AddScore("Joana", 100);
            hsMng.AddScore("Trigonometria", 3.14f);

            hsMng.Save();
            Console.WriteLine(hsMng);
        }
    }
}
```